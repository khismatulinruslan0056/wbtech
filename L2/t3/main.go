package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	// объявляем переменную err типом указателя на структуру PathError из пакета os
	return err
	// структура PathError из пакета os реализует интерфейс
	// type error interface {
	//    Error() string
	// }
	// в момент вызова return у нас происходи каст к интерфейсу error,
	// который будет выглядеть условно следующим образом
	// &iface{
	//            tab:  &itab{inter: &type.error, _type: &type.*os.PathError, ...}, - то есть мета информацию (тип интерфейса, тип переменной, методы и тд) уже внесена
	//            data: nil, - значение переменной nil
	//        }
}

func main() {
	err := Foo()
	// получаем ошибку, которая является интерфейсом, а другими словами структурой iface,
	// которая не является пустой, как мы поняли выше

	fmt.Println(err)        // здесь вызывается err.Error() и получаем nil
	fmt.Println(err == nil) // у нас происходит сравнение tab == nil && data == nil поэтому получаем false
}

// отличие от пустого интерфейса:
// отсутствие методов для реализации / необходимо реализовать Error()
// разные структуры внутри интерфейсов eface / iface
// внутри лежит мета о типе переменной / мета о типе интерфейса, типе переменной, наборе методов и тд (таблица типа и методов)
